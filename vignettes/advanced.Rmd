---
title: "Advanced usage"
author: "Patrick Schratz, Kirill Müller"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kirill Müller}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

old.hooks = fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE)
```

# Deployment

## pkgdown deployment

You may optionally set the deployment branch to `gh-pages` and then change the branch serving your site in the Github repo settings (change it to `gh-pages`).
`pkgdown` sites of an R package can either be served from the `/docs` directory of the `master` branch of from the root of the `gh-pages` branch.
Using the latter option has the advantage to not have all the automatic commits from Travis in the `master` branch -> the `pkgdown` site will be "silently" updated in the background.
Simply set the `branch` argument in `step_push_deploy()` to `gh-pages`.

Also, make sure to set `orphan = TRUE`.
This causes the branch to only consist of the commit that was pushed to Github (which is what you want for the `gh-pages` branch).
Don't worry, this option won't work when pushing to the current branch, so no worries about accidentally deleting your whole repo ;-)
Now, `step_push_deploy(path = "docs", branch = "gh-pages", orphan = TRUE)` will deploy the files generated by `step_build_pkgdown()` to the `gh-pages` branch of your repo.

If you are running a build matrix or build stages on Travis, you only want to run the `pkgdown` building and deployment once.
However, sometimes you want to deploy multiple files in different stages.
You can restrict on which stage/job a task is executed with the help of environment variables.
There are two ways to restrict the deployment with `tic` and environment variables: 

1. Setting the condition in `tic.R`
2. Setting the condition directly in `.travis.yml` in the "deploy" section

Sometimes, env variables are implicitly set, e.g. when testing on multiple R versions (see example 2) (or by Travis itself, see [Travis CI Meta-Information](advanced.html#travis-ci-meta-information)).
There is no practical difference between both approaches.
However, conditioning like shown here does only work for the "deploy" stage in `.travis.yml`.
For [conditioning other stages](advanced.html#running-stages-conditionally), you need to use the `tic` approach.

In the following we prepared an example for each option:

1. Specifically set the env variable `BUILD_PKGDOWN` in `.travis.yml` and add the condition in `tic.R` to only run the deploy stage when this env variable evaluates to TRUE:

```yml
jobs:
  include:
    - stage: stage1
      env: BUILD_PKGDOWN=TRUE
      before_install: R -q -e 'install.packages("remotes"); remotes::install_github("ropenscilabs/tic"); tic::prepare_all_stages(); tic::before_install()'
      [...]
      deploy:
        provider: script
        script: R -q -e 'tic::deploy()'
        on:
          all_branches: true
    - stage: stage2
      before_install: R -q -e 'install.packages("remotes"); remotes::install_github("ropenscilabs/tic"); tic::prepare_all_stages(); tic::before_install()'
      [...]
      deploy:
        provider: script
        script: R -q -e 'tic::deploy()'
        on:
          all_branches: true
```

`tic.R`:

```r
if (Sys.getenv("id_rsa") != "") {
  get_stage("before_deploy") %>%
    add_step(step_setup_ssh())
}

if (Sys.getenv("BUILD_PKGDOWN") != "") {
  get_stage("deploy") %>%
    add_step(step_build_pkgdown()) %>%
    add_step(step_push_deploy())
}
```

2. Setting the condition directly in `.travis.yml` in the "deploy" section:

This can be useful when you run a build matrix which tests multiple R versions that has the same workflow for every job:

```
r:
  - release
  - devel
  - oldrel
```

Here we restrict the deployment on three conditions: 

- No Pull Request
- No CRON job ([CRON jobs](https://docs.travis-ci.com/user/cron-jobs/) are builds that are started automatically after no build was triggered after a specific time)
- Only for builds that use the R "devel" version

```yml
deploy:
   provider: script
   script: R -q -e 'tic::deploy()'
   on:
     branch: master
     condition:
       - $TRAVIS_PULL_REQUEST = false
       - $TRAVIS_EVENT_TYPE != cron
       - $TRAVIS_R_VERSION_STRING = devel
```

The same could optionally also be specified in `tic.R`. 
There is no difference between the two approaches:

```r
if (Sys.getenv("BUILD_PKGDOWN") != "" && 
  Sys.getenv("TRAVIS_EVENT_TYPE") != "cron" && 
    Sys.getenv("TRAVIS_R_VERSION_STRING") == "devel") {
  get_stage("deploy") %>%
    add_step(step_build_pkgdown()) %>%
    add_step(step_push_deploy())
}
```

## Committing single files

Function `step_push_deploy()` has the ability to only commit and push single files if they have changed during a CI build.
This can be very useful for conditionally pushing documentation files like `NEWS` or `man/` and `NAMESPACE` if these are automatically created via Travis.
First, you need to make sure these files are created correctly by calling `devtools::document()`.
Then, simply add the desired paths to argument `commit_paths` in `step_push_deploy()` and push to your desired branch (here `master`):

```r
get_stage("before_deploy") %>%
    add_step(step_setup_ssh())

  get_stage("deploy") %>%
    add_code_step(devtools::document(roclets=c('rd', 'collate', 'namespace'))) %>%
    add_step(step_push_deploy(orphan = FALSE, branch = "master", 
                              commit_paths = c("NAMESPACE", "man/*")))
```

Applying this idea of course depends on your overall R package development strategy: Commit files like `/man/` and `NS` directly or let them be created by Travis? 
An example project that uses the latter strategy is [mlr](https://github.com/mlr-org/mlrng/blob/master/tic.R).

# Running stages conditionally

As introduced in the [prior section](advanced.html#deployment), conditioning of commands is based on env variables.
The most common use case is the testing on multiple R versions but if you test on multiple CI services you may also want to only run certain tasks on one of them.
We already explained [how to do so](advanced.html#pkgdown-deployment) if you are deploying a`pkgdown` site.

Another task is the code coverage generation.
You do not want to run this on every R version as the outcome will always be the same. 
Also it increases the build time on every build which is not what you want!
So, it is sufficient to just run it on one R version, e.g. "release".
When you use multiple R versions, Travis automatically sets up a build matrix with each build having [set an environmental variable for the R version](https://docs.travis-ci.com/user/languages/r/#Environment-Variables) used.
So all you need to do is to condition the stage execution on this env variable:

```r
if (Sys.getenv("TRAVIS_R_VERSION") == "release") {
  get_stage("after_success") %>%
    add_step(covr::codecov())
}
```

Note that setting the `after_success` stage explicitly will overwrite what `add_package_checks()` would do in the background for this particular stage (which is what you want if you define the step on your own).

Another condition that comes in handy is to run certain stages only on Travis CI (e.g. the code coverage step):

```r
if (inherits(ci(), "TravisCI") {
  get_stage("after_success") %>%
    add_step(covr::codecov())
}
```

# Installing packages

## Github packages

Github packages should be installed in the `install` stage:

```r
get_stage("install") %>%
  add_code_step(step_install_github("r-lib/rcmdcheck"))
```

Note that the underlying `remotes::install_github()` is vectorized for the `repo` argument which means you can pass all packages you want to install in a single function call: `add_code_step(step_install_github(c("r-lib/rcmdcheck", "r-lib/usethis"))`.

## CRAN packages

Sometimes you need to install CRAN packages that are not specified in the DESCRIPTION file of your package.
For example, to create a favicon in `pkgdown`, the `magick` package is required.
To install the package (only if it does not exist in the cache already), run the following:

```r
get_stage("install") %>%
  add_code_step(step_install_cran("magick"))
```

# Travis CI Meta-Information

The `ci()` function holds valuable information about the CI system. 
It can be used to query information that can be again be utilized for conditioning stages or steps.

For example, the user may wish to only deploy on Travis by using `inherits(ci(), "TravisCI")`:

```r
if (inherits(ci(), "TravisCI")) {
  get_stage("before_deploy") %>%
    add_step(step_setup_ssh())

  get_stage("deploy") %>%
    add_step(step_push_deploy())
}
```

See `?ci` for more information on which information can be extracted from this function.

# Troubleshooting: Running tic locally

You can run `tic` locally by using `load_from_file()`.
This function sources your `tic.R` file and reports eventual problems.

To emulate a CI run locally, you can simply call `tic()` and the stages and steps will be executed in your local R console.
Note that doing this will use your local system libraries and not the Travis environment.

# Troubleshooting: Entering the CI build

If your Travis build fails and you have no clue why (error messages are too unspecific, you cannot reproduce the problem locally), you can enter into the Travis build via `ssh`.
To do so, your repository must be [opt-in](https://docs.travis-ci.com/user/running-build-in-debug-mode/#enabling-debug-mode) for "ssh debugging".

Afterwards, you can simply call `travis::travis_debug_job(<jobID>)` and the build will restart.

Wait a few minutes until the build arrives at the point when it prints you the `ssh` command you can use to log in.
It should look similar to `ssh ukjiuCEkxBBnRAe32Y8xCH0zj@ny2.tmate.io`.

Once you are in the build [check](https://docs.travis-ci.com/user/running-build-in-debug-mode/#Things-to-do-once-you-are-inside-the-debug-VM) these handy functions to execute specific stages.

# What's not covered yet?

- `SystemRequirements`: `tic` is not yet capable of automatically determining system requirements specified in DESCRIPTION files of an R package. 
Our plan is to automatically provide suggestions like "Please add addons: apt: <library> to `.travis.yml`".
